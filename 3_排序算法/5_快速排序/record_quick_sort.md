### 快速排序
选取序列中的任一数据作为分区点，将小于分区点的数据放在分区点的左边，大于分区点的数据放在右边。对分区点左边的序列和右边的序列再进行一次快排，直到序列中的数据少于或等于一个时，表示该区间的数据已经排序完成，当所有序列都排序完成后，就完成了排序。  

#### 分区点的选择
即可以选择第一个元素作为分区点，也可以使用最后一个元素作为分区点，一般情况下选择最后一个元素作为分区点。  

#### 分析
- 是否为原地排序算法
  - 是
- 是否为稳定的排序算法
  - 否
- 时间复杂度
  - 最好情况下的时间复杂度：**$O(nlogn)$**
  - 最坏情况下的时间复杂度：**$O(n^2)$**
  - 平均情况下的时间复杂度：**$O(nlogn)$**

**时间复杂度的分析**
快速排序的时间复杂度可以套用归并排序的分析方法。  
即：
```
T(1) = C
T(n) = 2^log2(n) * T(1) + log2(n) * n
     = n*C + n*log2(n)
```
但是这种情况只有在每一次分区的时候都正好分成左右各一半的时候。所以最好情况下的时间复杂度就为 **$O(nlogn)$**  
在最坏情况下，如果分区正好是一个分区为空，另一个分区是满的，这就会变成类似于冒泡的形式，每一次排序只能确定一个元素的位置，所以最坏情况下的时间复杂度就为 **$O(n^2)$** 。  
而平均情况下的时间复杂度还是 **$O(nlogn)$**

#### 思考
**查找第k大的元素**  
普遍的做法是先对数组进行排序，然后第 k+1 个元素就是第 k 大的元素。这种情况下的时间复杂度主要取决于排序算法的时间复杂度，一般来说是 **$O(nlogn)$**  
通过快排的思路可以将时间复杂度降到 **O(n)**，主要是通过快排的分区算法，将数组根据分区点分为左右两个区间，如果分区点位于 k-1 的位置，分区点就为查找的第 k 个元素。否则，如果分区点大于k-1，则表示最终结果在左区间的数组中。否则在右区间中。然后只需要在对区间内的序列再做分区，就可以找到目标元素。
