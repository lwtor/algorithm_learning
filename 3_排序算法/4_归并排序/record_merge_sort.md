### 归并排序
采用分治的思想，将一个大问题拆分成两个小问题来解决。即将序列拆分成两个序列进行排序，再将已经排好序的两个序列进行合并，则得到一个排序好的序列。通过将序列不断的进行拆分，知道序列中只有一个元素为止。整体的实现思路就是采用递归的方式。  

```
// 整体的实现思路，伪代码表示
merge_sort(list){
  merge_list(list, 0, list.size)
}

// 对输入的指定位置的数据进行排序
merge_list(list, start, end){
  if(end - start <= 1){
    // 只有一个元素
    return
  }
  // 中间位置
  center = (end + start) / 2
  // 对前半段数据进行排序
  merge_list(list, start, center)
  // 对后半段数据进行排序
  merge_list(list, center, end)
  // 合并两端已经排序好的数据
  merge(list, start, center, end)
}
```

#### 分析
- 是否为原地排序算法
  - 否，空间复杂度：**$O(n)$**
- 是否为稳定的排序算法
  - 是
- 时间复杂度
  - 最好情况下的时间复杂度：**$O(n\log_2n)$**
  - 最坏情况下的时间复杂度：**$O(n\log_2n)$**
  - 平均情况下的时间复杂度：**$O(n\log_2n)$**

**时间复杂度推导过程**  
假设序列中有 n 个元素，则使用归并排序所需要的时间就为 T(n) 。  
由于合并两个共包含 n 个元素的有序序列的时间为 O(n) 。  
则有：  
```
T(n) = T(n/2) + T(n/2) + n = 2 * T(n/2) + n  
     = 2 * (2 * T(n/4) + n/2) + n   = 4 * T(n/4) + 2*n
     = 4 * (2 * T(n/8) + n/4) + 2*n = 8 * T(n/8) + 3*n
     = 2^k * T(n/2^k) + k*n

T(1) = C
```
通过对n的不断拆分，当到达递归终止时，即 T(1) 时，此时 n/2^k = 1，则 k = log2(n)，代入 T(n) 的公式中，则有  
```
// 公式：a^loga(n) = n
T(n) = 2^log2(n) * T(1) + log2(n) * n
     = n*C + n*log2(n)
```
