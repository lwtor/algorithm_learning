### 链表
#### 基础知识
1. 通过指针将一组零散的内存块串联起来
2. 结点：每一个内存块称为一个结点
3. 后继指针：每一个结点中用于记录下一个结点内存地址的指针
4. 头结点：第一个结点，记录链表的基内存地址
5. 尾结点：最后一个结点，其后继指针为null

#### 缓存淘汰算法
在缓存淘汰算法LRU（最近最少使用缓存淘汰算法）中  
缓存淘汰算法主要有：
- FIFO（First In, First Out）：先进先出策略
- LFU（Least Frequently Used）：最少使用策略
- LRU（Least Recently Used）：最近最少使用策略

#### 分类
- 单链表
  - 插入数据的时间复杂度：O(1)
  - 删除数据的时间复杂度：O(1)
  - 随机访问的时间复杂度：O(n)
- 双向链表
  - 尾结点的后继指针指向头结点
  - 适合处理具有环型结构的数据，例如约瑟夫问题
- 循环链表
  - 每个结点不仅有后继指针还有前继指针，前继指针指向上一个结点
  - 能够支持双向遍历
  - 在删除结点x问题上，双向链表的时间复杂度为O(1)，而单链表和循环链表为O(n)，因为在删除时需要知道结点x的前继结点
  - 在结点k前插入一个新的结点也有上面的优势
- 双向循环列表
  - 顾名思义，就是双向列表加上循环列表，头结点的前继指针指向尾结点，尾结点的后继指针指向头结点

#### 操作
 - 单链表反转
 - 有序链表合并
 - 链表中环的检测
 - 删除链表倒数第n个结点
 - 求链表的中间结点

#### 哨兵结点
空的表头结点，用于简化删除最后一个结点和删除最后一个结点的操作。  
包含哨兵结点的链表叫作`带头链表`，相反，没有哨兵结点的链表叫作`不带头链表`  
哨兵结点还可以用于 `插入排序` ， `并归排序` ， `动态规划`

#### Java中的使用
Java中的LinkedHashMap的实现原理就是用了双向列表实现的

#### 使用python实现LRU
添加数据时分为以下两种情况
 1. 如果缓存中已经该数据了，将该数据取出，并作为头结点
 2. 如果缓存中没有该数据，则需要考虑缓存的内存
  * 如果缓存未满，则将该数据作为头结点加入到缓存中
  * 如果缓存已经满了，则删除尾结点，再将该数据作为头结点加入缓存中

除了使用来链表来实现该算法，也使用数组来实现一次

#### 思考
  使用单链表存储字符串，判断字符串是否是回文字符串？
