### 数组
#### 基础知识
1. 线性表数据结构
2. 从0开始编号
3. 连续的内存空间

#### 优势
1. 由于使用的是连续的内存区域，查找的时间复杂度为 O(1)

#### 劣势
1. 插入或者删除元素的时候，需要对插入或者删除的位置后面的元素进行位移操作

#### 特殊的插入操作
将元素x插入到k位置，把原来k位置的元素插入到数组的尾部，把元素x插入到k位置。  
暂不清楚该用法的适用场景，快排中会使用到
```python
  val temp = list[k]
  list[k] = x
  list.append(temp)
```

#### 特殊的删除操作
记录下需要删除的数据，但不在数组中进行操作，等数组的空间不足时，再执行删除操作，把记录下的数据进行删除。  
用于`JVM标记清除垃圾回收算法`

#### Java中的ArrayList
在Java中，ArrayList容器的内部就是通过数组进行实现的，在初始化的时候会默认给数组设定一个固定的大小，当内存空间不足时，会对数组进行自动扩容的操作，扩容需要对数据进行搬移的操作。所以在已知数据长度的时候，最好指定所需的数组长度。  
ArrayList无法存储基本数据类型，如int、float，如果使用封装类型Int、Float，而其中的Autoboxing、Unboxing需要一定的性能消耗，此时最好使用数组。
##### 在python中指定list长度的方法
 ```python
    a = [None] * 4
    // range返回的是可迭代对象
    b = list(range(10))
 ```

#### 为什么下标从0开始
当下标从0开始，由于数组使用联系内存，在计算指定位置的数据时可以直接使用以下的方式计算  
`a[k]_address = base_address + k * (type_size)`  
如果从1开始计算，则会变成  
`a[k]_address = base_address + (k -1) * (type_size)`  
虽然看起来只是多了一次的减一的操作，但对于cpu来说则是多了一个减法指令。  
但是更多的原因可能只是历史原因，从一开始就是这么设计的，所以后来也都按照这种方式进行设计。减少之后的学习成本

#### 关于标记清除垃圾算法
待补充。。。
